# EPI (Elements of Programming Interviews) Problem Solving Notes

This repository contains my **solutions, notes, and observations** while working through the *Elements of Programming Interviews* (EPI) book. The goal is to **internalize fundamental data structures, algorithms, and problem-solving patterns** relevant for software engineering and quantitative trading interviews.

---

## Table of Contents

1. [Introduction](#introduction)  
2. [Chapters Covered](#chapters-covered)  
3. [Problem-Solving Approach](#problem-solving-approach)  
4. [Folder Structure](#folder-structure)  
5. [Resources](#resources)  
6. [License](#license)  

---

## Introduction

This repository serves as a **living notebook** for working through EPI problems. It includes:

- C++ implementations of problems  
- Step-by-step notes on **algorithmic thinking**  
- Observations about time and space complexity  
- Alternative solutions and optimizations  
- References to additional resources or tutorials

> Focused on **preparing for technical interviews**, especially **quantitative, algorithmic, and software engineering roles**.

---

## Chapters Covered

I am systematically working through the following chapters, roughly in order of interview relevance:

1. **Primitive Types**  
2. **Arrays**  
3. **Strings**  
4. **Linked Lists**  
5. **Stacks & Queues**  
6. **Binary Trees**  
7. **Heaps**  
8. **Searching**  
9. **Hash Tables**  
10. **Sorting**  
11. **Binary Search Trees**  
12. **Recursion**  
13. **Dynamic Programming**  
14. **Greedy Algorithms and Invariants**  
15. **Graphs**  
16. **Parallel Computing**  
17. **Design Problems**  
18. **Language Questions / C++ Specifics**  
19. **Object-Oriented Design**  
20. **Common Tools & Tricks**  

---

## Problem-Solving Approach

For each problem, I follow a structured methodology:

1. **Read & Understand**: Carefully read the problem and constraints.  
2. **Brute Force**: Consider a simple brute-force approach first.  
3. **Optimize**: Identify inefficiencies and optimize iteratively.  
4. **Implement**: Write clean, readable C++ code with comments.  
5. **Test**: Validate using multiple test cases.  
6. **Reflect**: Note time/space complexity and lessons learned.  
7. **Pattern Recognition**: Identify common patterns (sliding window, recursion, bit manipulation, etc.).  

> Notes may include **diagrams, pseudocode, and references** to related problems.

---
